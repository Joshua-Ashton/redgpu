https://twitter.com/ID_AA_Carmack/status/851397231320150017

“Why this API exists? I’ve heard Metal, D3D12, Vulkan or libraries like BGFX cover everyone?”

Not me. D3D12 and Vulkan (currently, REDGPU doesn’t target Metal API) are not good APIs. They’re good only in one dimension: explicit independence of API calls from each other compared to the previous generation of APIs. In all other dimensions, D3D12 and Vulkan are worse than REDGPU.

Performance: there are so many non-inherent (i.e. not related to the actual problem of feeding asynchronous parallel hardware with work) landmines and unnecessary boilerplate in D3D12 and Vulkan that some professional graphics programmers think these APIs were created to secure the job of graphics programming. Everyone understands that the problem can be made simpler without sacrifices in independence, performance and robustness of API calls, but no one did nor, apparently, can do the necessary work to make it so. REDGPU calls are explicitly independent from each other, as fast runtime-wise as its backend API allows and fully robust, with the most minimal amount of code required to solve actual problems a graphics programmer may have. The whole API with WSI extensions is 1300 lines of simplest possible C99 header code that can do everything D3D12 and Vulkan can, minus features modern hardware don’t have or GPU drivers are bad at.

Robustness: the designers of D3D12 and Vulkan APIs apparently live in their own imaginary world where GPU drivers are perfect, because I can’t explain why they have features that don’t solve problems well and cause trivial driver bugs, features that will be lower level when ISVs will force IHVs to make them lower level in order to be actually usable, or features that won’t be relevant in the near future at all. The libraries like BGFX are even worse than raw D3D12 and Vulkan, no serious graphics programmer wants to deal with unnecessary complexity, bad interfaces and lack of robustness these libraries present. The programmers behind these libraries list the benefits such as “simplicity”, “portability” and “ease of use”, but in the real world all they produce is unstructured, bloated, unreliable, interconnected C++ mess, allocating memory, writing to memory and keeping shadow states whenever they want, removing crucial features and guarantees of GPU APIs they use underneath. REDGPU is very small (you’ll be surprised when you’ll learn how small its binaries are, the implementation of REDGPU API is written in pure C99 with no dependencies on any other library, including no dependencies on standard C or C++ libraries), it doesn’t allocate any memory from the heap, it doesn’t keep any state behind your back, it doesn’t do anything that can cause multi-threading bugs within the API, and removes features that can cause unpredictable runtime behavior on bad GPU drivers. Of course, at some point, drivers must be any good to execute GPU code correctly, but that’s the lowest bar an API such as REDGPU can rely on without an access to GPU-specific assembly instructions, driver code, firmware and hardware documentation. We do live in a “There’s an API for that” GPU world, unfortunately, but REDGPU tries really hard to make it as suckless as possible.

Intuitiveness: this is the secret sauce of REDGPU API. It’s hard to describe, but once you see it you won’t go back to D3D12 or Vulkan. Once it click in your head, it’ll never leave. You will not need endless books or specifications to know how to solve particular GPU problems, that’s how powerful the realization will be.
